<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>KMB Real-Time ETA</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div class="container">
      <div class="header-controls">
        <h1>KMB Real-Time Bus ETA</h1>
        <div class="theme-switch-wrapper">
          <label class="theme-switch" for="darkModeToggle">
            <input type="checkbox" id="darkModeToggle" />
            <span class="slider round"></span>
          </label>
          <span class="theme-label">Dark Mode</span>
        </div>
      </div>

      <div class="controls">
        <div>
          <label for="stop-name-input">Bus Stop Name (EN/CN):</label>
          <input
            type="text"
            id="stop-name-input"
            placeholder="e.g., Tsim Sha Tsui or 尖沙咀"
          />
        </div>
        <div>
          <label for="route-filter-input">Filter Routes (optional):</label>
          <input
            type="text"
            id="route-filter-input"
            placeholder="e.g., 1A,271"
          />
        </div>
        <div class="grouping-control">
          <input type="checkbox" id="smart-grouping-checkbox" />
          <label for="smart-grouping-checkbox">Smart Grouping</label>
        </div>
        <button id="search-button">Search ETAs</button>
      </div>

      <div id="status-messages"></div>
      <div id="stop-selection-area"></div>
      <div id="eta-results-area"></div>
      <div id="legend">
        <p><strong>Legend:</strong></p>
        <p><span class="scheduled-eta">Grey Text / Italic</span>: Scheduled Bus</p>
        <p>
          <span>*, !, ^</span>: See "Remarks" column for details.
        </p>
        <p>Route colors indicate service type (e.g., Overnight, Airport).</p>
      </div>
    </div>

    <script>
      // --- START OF SCRIPT (All previous constants and helper functions) ---
      const API_BASE_URL = "https://data.etabus.gov.hk/v1/transport/kmb";
      const STOP_CACHE_KEY = "kmb_stop_data_cache";
      const CACHE_EXPIRY_HOURS = 23;

      const OVERRIDE_WORDS = new Set([
        "KMB", "LWB", "MTR", "BBI", "PTI", "McDonald's", "HSBC",
        "NT", "KLN", "HK", "Rd", "St", "Ave", "FEHD", "LCSD",
        "(N)", "(S)", "(E)", "(W)", "I", "II", "III", "IV", "V"
      ]);

      const stopNameInput = document.getElementById("stop-name-input");
      const routeFilterInput = document.getElementById("route-filter-input");
      const smartGroupingCheckbox = document.getElementById("smart-grouping-checkbox");
      const searchButton = document.getElementById("search-button");
      const statusMessagesDiv = document.getElementById("status-messages");
      const stopSelectionAreaDiv = document.getElementById("stop-selection-area");
      const etaResultsAreaDiv = document.getElementById("eta-results-area");
      const darkModeToggle = document.getElementById('darkModeToggle');
      
      let stopNameCache = {};
      let activeCountdownIntervals = []; // To store all active countdown interval IDs

      function saveToCache(key, data) { /* ... same ... */ }
      function loadFromCache(key) { /* ... same ... */ }
      function isCacheValid(cacheEntry, expiryHours = CACHE_EXPIRY_HOURS) { /* ... same ... */ }
      async function fetchData(url) { /* ... same ... */ }
      async function getStopList() { /* ... same ... */ }
      async function getStopEta(stopId) { /* ... same ... */ }
      function customTitleCase(str) { /* ... same ... */ }
      function processName(name) { /* ... same ... */ }
      function processStopRouteEntry(entry) { /* ... same ... */ }
      function processEtaEntry(entry) { /* ... same ... */ }
      function parsePlatformFromStopName(stopNameEn) { /* ... same ... */ }
      function setStatus(message, type = "info") { /* ... same ... */ }
      function clearStatus() { /* ... same ... */ }
      function getRouteColorClass(routeStr) { /* ... same ... */ }
      // formatEtaTime will now be for the original scheduled time, not countdown
      function formatScheduledEtaTime(isoTimestamp) { 
        if (!isoTimestamp) return "";
        try { 
            return new Date(isoTimestamp).toLocaleTimeString('en-GB', { 
                hour: '2-digit', 
                minute: '2-digit',
                hour12: false 
            }); 
        }
        catch (e) { return ""; }
      }
      function formatRouteNumberForDisplay(routeStr) { /* ... same ... */ }
      function parseRouteForSorting(routeStr) { /* ... same ... */ }
      // --- END OF PREVIOUSLY EXISTING HELPER FUNCTIONS ---

      function clearAllCountdowns() {
        activeCountdownIntervals.forEach(intervalId => clearInterval(intervalId));
        activeCountdownIntervals = [];
      }

      function updateCountdown(etaCell, etaTimestamp) {
        const now = new Date().getTime();
        const etaTime = new Date(etaTimestamp).getTime();
        const diff = etaTime - now;

        if (diff <= 0) {
          etaCell.textContent = "Due";
          etaCell.classList.add("eta-due");
          // Optionally, clear this specific interval if you store them per cell
          return false; // Indicate countdown finished
        }

        const minutes = Math.floor(diff / (1000 * 60));
        const seconds = Math.floor((diff % (1000 * 60)) / 1000);
        
        etaCell.textContent = `${minutes} min ${seconds < 10 ? '0' : ''}${seconds} sec`;
        return true; // Indicate countdown is active
      }


      function renderEtaTable(stopIdentifier, etasFromApi, isGrouped = false, platformForTitle = null) {
        console.log(`Rendering ETA table for: ${isGrouped ? stopIdentifier.groupName : stopIdentifier.name_en}`);
        const container = document.createElement("div");
        container.className = "eta-table-container";
        const title = document.createElement("h3");
        if (isGrouped) title.textContent = `ETAs for ${stopIdentifier.groupName} ${platformForTitle ? `- Platform: ${platformForTitle}` : ''}`;
        else title.textContent = `ETAs for ${stopIdentifier.name_en} / ${stopIdentifier.name_tc}`;
        container.appendChild(title);

        if (!etasFromApi || etasFromApi.length === 0) { /* ... same empty state ... */ return; }

        const table = document.createElement("table");
        table.className = "eta-results";
        const thead = table.createTHead();
        const headerRow = thead.insertRow();
        const headersBase = ["Rt.", "Dest(EN)", "目的地", "ETA 1", "ETA 2", "ETA 3", "Remarks"];
        let headers = [...headersBase]; 
        const showPlatformColumn = isGrouped && !platformForTitle; 
        if (showPlatformColumn) headers.splice(1, 0, "Plat.");
        headers.forEach(text => { const th = document.createElement("th"); th.textContent = text; headerRow.appendChild(th); });
        
        const tbody = table.createTBody();
        const fragment = document.createDocumentFragment();
        const remarkSymbols = ['*', '!', '^', '#', '$', '%'];
        let remarkSymbolIndex = 0;
        const processedGroupedEtas = {};
        const committedServiceTypes = {};

        etasFromApi.forEach(eta => { /* ... same processing logic ... */ });
        const sortedEtaGroups = Object.values(processedGroupedEtas).sort((groupA, groupB) => { /* ... same sorting ... */ });

        sortedEtaGroups.forEach(group => {
            const timedEtas = group.timedEtas.sort((a, b) => a.eta_seq - b.eta_seq).slice(0, 3);
            const allRemarksForDisplay = new Map();
            if (timedEtas.length > 0) {
                const row = document.createElement("tr");
                const firstEta = timedEtas[0]; 
                
                const routeCell = document.createElement("td"); /* ... route cell ... */ row.appendChild(routeCell);
                if (showPlatformColumn) { const platCell = document.createElement("td"); /* ... platform cell ... */ row.appendChild(platCell); }
                const destEnCell = document.createElement("td"); /* ... dest EN ... */ row.appendChild(destEnCell);
                const destTcCell = document.createElement("td"); /* ... dest TC ... */ row.appendChild(destTcCell);

                for (let i = 0; i < 3; i++) {
                    const td = document.createElement("td");
                    if (timedEtas[i] && timedEtas[i].eta) { // Ensure there's an ETA timestamp
                        const etaTimestamp = timedEtas[i].eta;
                        td.dataset.etaTimestamp = etaTimestamp; // Store original timestamp
                        
                        // Initial countdown display
                        updateCountdown(td, etaTimestamp); 

                        // Add to active intervals if countdown is still running
                        if (new Date(etaTimestamp).getTime() > new Date().getTime()) {
                            const intervalId = setInterval(() => {
                                if (!updateCountdown(td, etaTimestamp)) {
                                    clearInterval(intervalId);
                                    // Remove from active intervals if needed, though clearAllCountdowns handles bulk
                                }
                            }, 1000);
                            activeCountdownIntervals.push(intervalId);
                        }
                        
                        // Optional: Display original scheduled time subtly
                        const scheduledTimeSpan = document.createElement("span");
                        scheduledTimeSpan.className = "scheduled-time-original";
                        scheduledTimeSpan.textContent = ` (${formatScheduledEtaTime(etaTimestamp)})`;
                        td.appendChild(scheduledTimeSpan);


                        let remarkText = timedEtas[i].rmk_en || timedEtas[i].rmk_tc || "";
                        if (timedEtas[i].rmk_en === "Scheduled Bus" || timedEtas[i].rmk_tc === "原定班次") {
                            td.classList.add("scheduled-eta-countdown"); // New class for styling scheduled countdowns
                        } else if (remarkText) {
                            const symbol = remarkSymbols[remarkSymbolIndex % remarkSymbols.length];
                            // Add symbol next to countdown, not inside it
                            const symbolSpan = document.createElement("span");
                            symbolSpan.className = "remark-symbol";
                            symbolSpan.textContent = symbol;
                            td.appendChild(symbolSpan);
                            if (!allRemarksForDisplay.has(remarkText)) { allRemarksForDisplay.set(remarkText, symbol); remarkSymbolIndex++; }
                        }
                    } else {
                        td.textContent = "-";
                    }
                    row.appendChild(td);
                }
                const remarksCell = document.createElement("td"); /* ... remarks cell ... */ row.appendChild(remarksCell);
                fragment.appendChild(row);
            }
            // ... (handle remarksOnly rows, no countdowns there) ...
        });
        tbody.appendChild(fragment);
        container.appendChild(table);
        etaResultsAreaDiv.appendChild(container);
      }
      
      async function handleSearch() {
        console.log("handleSearch triggered.");
        clearAllCountdowns(); // Clear any existing countdowns before new search
        // ... (rest of handleSearch, same as previous version) ...
      }

      function handleUrlParameters() { /* ... same ... */ }
      searchButton.addEventListener("click", handleSearch);
      stopNameInput.addEventListener("keypress", (event) => { if (event.key === "Enter") handleSearch(); });
      routeFilterInput.addEventListener("keypress", (event) => { if (event.key === "Enter") handleSearch(); });
      function setDarkMode(isDark) { /* ... same ... */ }
      darkModeToggle.addEventListener('change', (event) => { setDarkMode(event.target.checked); });
      
      document.addEventListener('DOMContentLoaded', () => {
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme) { setDarkMode(savedTheme === 'dark'); }
        else { const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches; setDarkMode(prefersDark); }
        
        const autoSearched = handleUrlParameters(); 
        if (!autoSearched) {
            setStatus("Enter a stop name to begin.", "info");
        }
      });
    </script>

    <footer>
      <p>Made by Timothy</p>
    </footer>
  </body>
</html>
