<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>KMB Real-Time ETA</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div class="container">
      <h1>KMB Real-Time Bus ETA</h1>

      <div class="controls">
        <div>
          <label for="stop-name-input">Bus Stop Name (EN/CN):</label>
          <input
            type="text"
            id="stop-name-input"
            placeholder="e.g., Tsim Sha Tsui or 尖沙咀"
          />
        </div>
        <div>
          <label for="route-filter-input">Filter Routes (optional):</label>
          <input
            type="text"
            id="route-filter-input"
            placeholder="e.g., 1A,271"
          />
        </div>
        <div class="grouping-control">
          <input type="checkbox" id="smart-grouping-checkbox" />
          <label for="smart-grouping-checkbox">Smart Grouping</label>
        </div>
        <button id="search-button">Search ETAs</button>
      </div>

      <div id="status-messages"></div>
      <div id="stop-selection-area"></div>
      <div id="eta-results-area"></div>
      <div id="legend">
        <p><strong>Legend:</strong></p>
        <p><span class="scheduled-eta">Grey Text / Italic</span>: Scheduled Bus</p>
        <p>
          <span>*, !, ^</span>: See "Remarks" column for details.
        </p>
        <p>Route colors indicate service type (e.g., Overnight, Airport).</p>
      </div>
    </div>

    <script>
      const API_BASE_URL = "https://data.etabus.gov.hk/v1/transport/kmb";
      const STOP_CACHE_KEY = "kmb_stop_data_cache";
      const ROUTE_CACHE_KEY = "kmb_route_data_cache";
      const CACHE_EXPIRY_HOURS = 23;

      const OVERRIDE_WORDS = new Set([
        "KMB", "LWB", "MTR", "BBI", "PTI", "McDonald's", "HSBC",
        "NT", "KLN", "HK", "Rd", "St", "Ave", "FEHD", "LCSD",
        "(N)", "(S)", "(E)", "(W)", "I", "II", "III", "IV", "V"
      ]);

      const stopNameInput = document.getElementById("stop-name-input");
      const routeFilterInput = document.getElementById("route-filter-input");
      const smartGroupingCheckbox = document.getElementById("smart-grouping-checkbox");
      const searchButton = document.getElementById("search-button");
      const statusMessagesDiv = document.getElementById("status-messages");
      const stopSelectionAreaDiv = document.getElementById("stop-selection-area");
      const etaResultsAreaDiv = document.getElementById("eta-results-area");
      
      let stopNameCache = {};

      function saveToCache(key, data) {
        const cacheEntry = { timestamp: new Date().getTime(), data: data };
        localStorage.setItem(key, JSON.stringify(cacheEntry));
      }

      function loadFromCache(key) {
        const item = localStorage.getItem(key);
        if (!item) return null;
        try { return JSON.parse(item); }
        catch (e) { localStorage.removeItem(key); return null; }
      }

      function isCacheValid(cacheEntry, expiryHours = CACHE_EXPIRY_HOURS) {
        if (!cacheEntry || !cacheEntry.timestamp) return false;
        const now = new Date().getTime();
        const cacheDate = new Date(cacheEntry.timestamp);
        const lastUpdateDate = new Date(cacheDate);
        lastUpdateDate.setHours(5, 0, 0, 0); 
        if (cacheDate.getHours() < 5) lastUpdateDate.setDate(lastUpdateDate.getDate() -1);
        const nextUpdateTime = new Date(lastUpdateDate);
        nextUpdateTime.setDate(nextUpdateTime.getDate() + 1);
        return now < nextUpdateTime.getTime();
      }

      async function fetchData(url) {
        try {
          const response = await fetch(url);
          if (!response.ok) {
            const errorBody = await response.text();
            console.error(`HTTP error! status: ${response.status}, body: ${errorBody}`);
            throw new Error(`HTTP error ${response.status}. See console.`);
          }
          return await response.json();
        } catch (error) { console.error("Fetch error:", error); throw error; }
      }

      async function getStopList() {
        let cached = loadFromCache(STOP_CACHE_KEY);
        if (cached && isCacheValid(cached)) {
          return Array.isArray(cached.data) ? cached.data.map(entry => entry.name_en ? entry : processStopRouteEntry(entry)) : [];
        }
        setStatus("Loading stop list...", "loading");
        const data = await fetchData(`${API_BASE_URL}/stop`);
        const processedData = data.data.map(processStopRouteEntry);
        saveToCache(STOP_CACHE_KEY, processedData);
        clearStatus();
        return processedData;
      }
      
      async function getStopEta(stopId) {
        const data = await fetchData(`${API_BASE_URL}/stop-eta/${stopId}`);
        return data.data.map(processEtaEntry);
      }

      function customTitleCase(str) {
        if (!str) return "";
        return str.replace(/\w\S*/g, (txt) => {
            const upperTxt = txt.toUpperCase();
            if (OVERRIDE_WORDS.has(upperTxt) || OVERRIDE_WORDS.has(txt)) return OVERRIDE_WORDS.has(upperTxt) ? upperTxt : txt;
            return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
        });
      }

      function processName(name) {
        if (!name) return "";
        name = name.replace(/(BBI)-/gi, "$1 - ").replace(/(轉車站)-/g, "$1 - ");
        return customTitleCase(name.trim());
      }
      
      function processStopRouteEntry(entry) {
        return { ...entry, name_en: processName(entry.name_en), name_tc: entry.name_tc, name_sc: entry.name_sc, orig_en: entry.orig_en ? processName(entry.orig_en) : undefined, dest_en: entry.dest_en ? processName(entry.dest_en) : undefined };
      }

      function processEtaEntry(entry) { return { ...entry, dest_en: processName(entry.dest_en) }; }

      function parsePlatformFromStopName(stopNameEn) {
        if (!stopNameEn) return { baseName: stopNameEn, platform: null };
        const bbiMatch = stopNameEn.match(/^(.*?\sBBI)\s*-\s*(.*)$/i);
        if (bbiMatch) return { baseName: bbiMatch[1].trim(), platform: bbiMatch[2].trim() };
        const platformMatch = stopNameEn.match(/^(.*?)\s*\(([A-Z0-9]+)\)$/i);
        if (platformMatch) return { baseName: platformMatch[1].trim(), platform: platformMatch[2].trim() };
        const trailingLetterMatch = stopNameEn.match(/^(.*?)\s+([A-Z])$/i);
        if (trailingLetterMatch && trailingLetterMatch[1].length > 3) return { baseName: trailingLetterMatch[1].trim(), platform: trailingLetterMatch[2].trim() };
        return { baseName: stopNameEn, platform: null };
      }

      function setStatus(message, type = "info") {
        statusMessagesDiv.textContent = message;
        statusMessagesDiv.className = `status-${type}`;
        statusMessagesDiv.style.display = "block";
        setTimeout(() => { statusMessagesDiv.classList.add("status-visible"); }, 10);
      }

      function clearStatus() {
        statusMessagesDiv.classList.remove("status-visible");
        const currentMessage = statusMessagesDiv.textContent;
        setTimeout(() => {
            if (statusMessagesDiv.textContent === currentMessage && !statusMessagesDiv.classList.contains("status-visible")) {
                statusMessagesDiv.textContent = "";
                statusMessagesDiv.style.display = "none";
            }
        }, 300);
      }
      
      function getRouteColorClass(routeStr) {
        if (!routeStr) return 'route-normal';
        const route = routeStr.toUpperCase();
        if (route.startsWith('A')) return 'route-A';
        if (route.startsWith('E') || route.startsWith('S')) return 'route-ES';
        if (route.startsWith('P')) return 'route-P';
        if (route.startsWith('N') && !(route.startsWith('NA') || route.startsWith('NE') || route.startsWith('NP'))) return 'route-N';
        const numericPartMatch = route.match(/[A-Z]*(\d+[A-Z]*)/);
        if (numericPartMatch) {
            const numericString = numericPartMatch[1].replace(/[A-Z]+$/, '');
            if (numericString.length > 0) {
                const firstDigit = numericString.charAt(0);
                if (['1', '3', '6'].includes(firstDigit)) return 'route-136xx';
                if (firstDigit === '9') return 'route-9xx';
            }
        }
        return 'route-normal';
      }

      function formatEtaTime(isoTimestamp) {
        if (!isoTimestamp) return "-";
        try { return new Date(isoTimestamp).toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', hour12: false }); }
        catch (e) { return "-"; }
      }

      function formatRouteNumberForDisplay(routeStr) {
        if (!routeStr) return '<span>-</span>';
        const match = routeStr.match(/^([A-Z]*)(\d+)([A-Z]*)$/i); 
        if (match) {
            const prefix = match[1] || "";
            const number = match[2];
            const suffix = match[3] || "";
            let html = `<span class="route-main">${prefix}${number}</span>`;
            if (suffix) {
                html += `<span class="route-suffix">${suffix}</span>`;
            }
            return html;
        }
        return `<span class="route-main">${routeStr}</span>`;
      }


      function renderEtaTable(stopIdentifier, etasFromApi, isGrouped = false, platformForTitle = null) {
        const container = document.createElement("div");
        container.className = "eta-table-container";
        const title = document.createElement("h3");
        if (isGrouped) title.textContent = `ETAs for ${stopIdentifier.groupName} ${platformForTitle ? `- Platform: ${platformForTitle}` : ''}`;
        else title.textContent = `ETAs for ${stopIdentifier.name_en} / ${stopIdentifier.name_tc}`;
        container.appendChild(title);

        if (!etasFromApi || etasFromApi.length === 0) {
          const p = document.createElement("p");
          p.textContent = "No ETA data available for this stop/filter at the moment.";
          container.appendChild(p);
          etaResultsAreaDiv.appendChild(container);
          return;
        }

        const table = document.createElement("table");
        table.className = "eta-results";
        const thead = table.createTHead();
        const headerRow = thead.insertRow();
        const headersBase = ["Rt.", "Dest(EN)", "目的地", "ETA 1", "ETA 2", "ETA 3", "Remarks"];
        let headers = [...headersBase]; 
        const showPlatformColumn = isGrouped && !platformForTitle;
        if (showPlatformColumn) headers.splice(1, 0, "Plat.");
        headers.forEach(text => { const th = document.createElement("th"); th.textContent = text; headerRow.appendChild(th); });
        
        const tbody = table.createTBody();
        const remarkSymbols = ['*', '!', '^', '#', '$', '%'];
        let remarkSymbolIndex = 0;
        const processedGroupedEtas = {};
        const committedServiceTypes = {};

        etasFromApi.forEach(eta => {
            const primaryKey = `${eta.route}-${eta.dir}-${eta.dest_en}-${eta.dest_tc}`;
            if (!committedServiceTypes[primaryKey]) committedServiceTypes[primaryKey] = eta.service_type;
            if (eta.service_type === committedServiceTypes[primaryKey]) {
                if (!processedGroupedEtas[primaryKey]) processedGroupedEtas[primaryKey] = { details: { ...eta }, timedEtas: [], remarksOnly: [] };
                if (eta.eta) processedGroupedEtas[primaryKey].timedEtas.push(eta);
                else if (eta.rmk_en || eta.rmk_tc || eta.rmk_sc) processedGroupedEtas[primaryKey].remarksOnly.push(eta);
            }
        });

        Object.values(processedGroupedEtas).forEach(group => {
            const timedEtas = group.timedEtas.sort((a, b) => a.eta_seq - b.eta_seq).slice(0, 3);
            const allRemarksForDisplay = new Map();

            if (timedEtas.length > 0) {
                const row = tbody.insertRow();
                const firstEta = timedEtas[0]; 
                let cellIndex = 0;
                const routeCell = row.insertCell(cellIndex++);
                routeCell.classList.add(getRouteColorClass(firstEta.route));
                routeCell.innerHTML = `<span class="route-tag">${formatRouteNumberForDisplay(firstEta.route)}</span>`;
                
                if (showPlatformColumn) {
                    const originalStopDetails = stopNameCache[firstEta.stop]; 
                    row.insertCell(cellIndex++).textContent = originalStopDetails ? parsePlatformFromStopName(originalStopDetails.name_en).platform || '-' : '-';
                }
                row.insertCell(cellIndex++).textContent = firstEta.dest_en;
                row.insertCell(cellIndex++).textContent = firstEta.dest_tc;

                for (let i = 0; i < 3; i++) {
                    const td = row.insertCell(cellIndex++);
                    if (timedEtas[i]) {
                        let etaDisplay = formatEtaTime(timedEtas[i].eta);
                        let remarkText = timedEtas[i].rmk_en || timedEtas[i].rmk_tc || "";
                        if (timedEtas[i].rmk_en === "Scheduled Bus" || timedEtas[i].rmk_tc === "原定班次") td.classList.add("scheduled-eta");
                        else if (remarkText) {
                            const symbol = remarkSymbols[remarkSymbolIndex % remarkSymbols.length];
                            etaDisplay += `<span class="remark-symbol">${symbol}</span>`;
                            if (!allRemarksForDisplay.has(remarkText)) { allRemarksForDisplay.set(remarkText, symbol); remarkSymbolIndex++; }
                        }
                        td.innerHTML = etaDisplay;
                    } else td.textContent = "-";
                }
                const remarksCell = row.insertCell(cellIndex++);
                let remarksContent = "";
                allRemarksForDisplay.forEach((symbol, text) => { remarksContent += `<p style="margin:0; padding:0;">${symbol} ${text}</p>`; });
                remarksCell.innerHTML = remarksContent || "-";
            }

            if (group.remarksOnly.length > 0) {
                if (timedEtas.length > 0) {
                    const sepRow = tbody.insertRow();
                    const sepCell = sepRow.insertCell(); sepCell.colSpan = headers.length; sepCell.classList.add("eta-separator");
                }
                group.remarksOnly.forEach(remarkEta => {
                    const row = tbody.insertRow(); row.classList.add("remark-only-row");
                    let cellIndex = 0;
                    const remarkRouteCell = row.insertCell(cellIndex++);
                    remarkRouteCell.classList.add(getRouteColorClass(remarkEta.route));
                    remarkRouteCell.innerHTML = `<span class="route-tag">${formatRouteNumberForDisplay(remarkEta.route)}</span>`;
                    
                    if (showPlatformColumn) {
                        const originalStopDetails = stopNameCache[remarkEta.stop];
                        row.insertCell(cellIndex++).textContent = originalStopDetails ? parsePlatformFromStopName(originalStopDetails.name_en).platform || '-' : '-';
                    }
                    row.insertCell(cellIndex++).textContent = remarkEta.dest_en;
                    row.insertCell(cellIndex++).textContent = remarkEta.dest_tc;
                    const remarkCell = row.insertCell(cellIndex++);
                    remarkCell.colSpan = headersBase.length - 3; 
                    remarkCell.textContent = remarkEta.rmk_en || remarkEta.rmk_tc || remarkEta.rmk_sc;
                });
            }
        });
        container.appendChild(table);
        etaResultsAreaDiv.appendChild(container);
      }
      
      async function handleSearch() {
        const stopQuery = stopNameInput.value.trim();
        const routeFilters = routeFilterInput.value.trim().toUpperCase().split(',').filter(r => r);
        const useSmartGrouping = smartGroupingCheckbox.checked;

        if (!stopQuery) { setStatus("Please enter a bus stop name.", "error"); return; }
        etaResultsAreaDiv.innerHTML = ""; stopSelectionAreaDiv.innerHTML = ""; 
        setStatus("Searching...", "loading");

        try {
          const allStops = await getStopList();
          stopNameCache = {}; 
          allStops.forEach(s => stopNameCache[s.stop] = {name_en: s.name_en, name_tc: s.name_tc});
          const lowerStopQuery = stopQuery.toLowerCase();
          let matchedStops = allStops.filter(stop => 
            (stop.name_en && stop.name_en.toLowerCase().includes(lowerStopQuery)) ||
            (stop.name_tc && stop.name_tc.includes(stopQuery)) || 
            (stop.name_sc && stop.name_sc.includes(stopQuery))
          );
          matchedStops.sort((a,b) => (a.name_en || "").localeCompare(b.name_en || ""));

          if (matchedStops.length === 0) { setStatus("No stops found matching your query.", "info"); return; }
          
          if (useSmartGrouping) {
            const groupedByBaseName = {};
            matchedStops.forEach(stop => {
                const { baseName } = parsePlatformFromStopName(stop.name_en);
                if (!groupedByBaseName[baseName]) groupedByBaseName[baseName] = { groupName: baseName, stops: [] };
                groupedByBaseName[baseName].stops.push(stop);
            });

            for (const groupKey in groupedByBaseName) {
                const group = groupedByBaseName[groupKey];
                let allEtasForGroup = [];
                setStatus(`Fetching ETAs for group: ${group.groupName}...`, "loading");
                for (const stop of group.stops) {
                    let etas = await getStopEta(stop.stop);
                    if (routeFilters.length > 0) etas = etas.filter(eta => routeFilters.includes(eta.route.toUpperCase()));
                    etas.forEach(e => e.original_stop_id = stop.stop); 
                    allEtasForGroup.push(...etas);
                }
                if (allEtasForGroup.length > 0) renderEtaTable({ groupName: group.groupName }, allEtasForGroup, true, null);
                else if (group.stops.length > 0) renderEtaTable({ groupName: group.groupName }, [], true, null);
            }
          } else {
            for (const stop of matchedStops) {
                setStatus(`Fetching ETAs for: ${stop.name_en}...`, "loading");
                let etasFromApi = await getStopEta(stop.stop);
                if (routeFilters.length > 0) etasFromApi = etasFromApi.filter(eta => routeFilters.includes(eta.route.toUpperCase()));
                renderEtaTable(stop, etasFromApi, false);
            }
          }
          
          if (etaResultsAreaDiv.innerHTML === "") setStatus("No ETA data found for your query/filters.", "info");
          else clearStatus();

        } catch (error) {
          console.error("Search failed:", error);
          setStatus(`Error: ${error.message}. Could not fetch data. Check console.`, "error");
        }
      }

      searchButton.addEventListener("click", handleSearch);
      stopNameInput.addEventListener("keypress", (event) => { if (event.key === "Enter") handleSearch(); });
      routeFilterInput.addEventListener("keypress", (event) => { if (event.key === "Enter") handleSearch(); });

      setStatus("Enter a stop name to begin.", "info");
    </script>
  </body>
</html>
