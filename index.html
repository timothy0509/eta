<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>KMB Real-Time ETA</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f4f4f4;
        color: #333;
      }
      .container {
        max-width: 1000px;
        margin: auto;
        background-color: #fff;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      }
      h1 {
        text-align: center;
        color: #d71920; /* KMB Red */
      }
      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        margin-bottom: 20px;
        align-items: flex-end;
      }
      .controls label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
      }
      .controls input[type="text"],
      .controls input[type="checkbox"] {
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
      }
      .controls input[type="text"] {
        flex-grow: 1;
        min-width: 200px;
      }
      .controls button {
        padding: 10px 15px;
        background-color: #d71920;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 1em;
      }
      .controls button:hover {
        background-color: #b8141a;
      }
      .grouping-control {
        display: flex;
        align-items: center;
        gap: 5px;
      }

      #status-messages {
        margin-bottom: 15px;
        padding: 10px;
        border-radius: 4px;
      }
      .status-loading {
        background-color: #eef;
        border: 1px solid #ccf;
      }
      .status-error {
        background-color: #fee;
        border: 1px solid #fcc;
        color: red;
      }
      .status-info {
        background-color: #eff;
        border: 1px solid #cff;
      }

      #stop-selection-area ul {
        list-style-type: none;
        padding: 0;
      }
      #stop-selection-area li {
        padding: 8px;
        border-bottom: 1px solid #eee;
        cursor: pointer;
      }
      #stop-selection-area li:hover {
        background-color: #f0f0f0;
      }
      #stop-selection-area li:last-child {
        border-bottom: none;
      }

      .eta-table-container {
        margin-bottom: 25px;
        overflow-x: auto;
      }
      .eta-table-container h3 {
        margin-top: 0;
        color: #555;
      }
      table.eta-results {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9em;
        margin-bottom: 10px;
      }
      table.eta-results th,
      table.eta-results td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
        white-space: nowrap;
      }
      table.eta-results th {
        background-color: #f0f0f0;
      }
      .scheduled-eta {
        color: grey;
      }
      .remark-symbol {
        font-weight: bold;
        margin-left: 2px;
      }
      .remark-only-row td {
        text-align: center !important;
        font-style: italic;
        color: #555;
      }
      .eta-separator td {
        border-top: 2px dotted #ccc !important;
        height: 0;
        padding: 0 !important;
        line-height: 0;
      }

      /* Route Colors - Add more as needed */
      .route-N { color: #000080; font-weight: bold; } /* Navy for N-routes */
      .route-1xx, .route-3xx, .route-6xx { color: #800000; } /* Maroon for 1/3/6xx */
      .route-9xx { color: #006400; } /* DarkGreen for 9xx */
      .route-P { color: #800080; } /* Purple for P-routes */
      .route-R { color: #ff8c00; } /* DarkOrange for R-routes */
      .route-HK { color: #228B22; } /* ForestGreen for HK-routes */
      .route-A, .route-E { color: #4682B4; } /* SteelBlue for Airport routes */
      .route-default { color: #333; }

      #legend {
        margin-top: 20px;
        padding: 10px;
        background-color: #f9f9f9;
        border: 1px solid #eee;
        border-radius: 4px;
        font-size: 0.9em;
      }
      #legend p { margin: 5px 0; }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>KMB Real-Time Bus ETA</h1>

      <div class="controls">
        <div>
          <label for="stop-name-input">Bus Stop Name (EN/CN):</label>
          <input
            type="text"
            id="stop-name-input"
            placeholder="e.g., Tsim Sha Tsui or 尖沙咀"
          />
        </div>
        <div>
          <label for="route-filter-input">Filter Routes (optional):</label>
          <input
            type="text"
            id="route-filter-input"
            placeholder="e.g., 1A,271"
          />
        </div>
        <div class="grouping-control">
          <input type="checkbox" id="smart-grouping-checkbox" />
          <label for="smart-grouping-checkbox">Smart Grouping</label>
        </div>
        <button id="search-button">Search ETAs</button>
      </div>

      <div id="status-messages"></div>
      <div id="stop-selection-area">
        <!-- Matching stops will be listed here if multiple -->
      </div>
      <div id="eta-results-area">
        <!-- ETA tables will be rendered here -->
      </div>
      <div id="legend">
        <p><strong>Legend:</strong></p>
        <p><span class="scheduled-eta">Grey Text</span>: Scheduled Bus</p>
        <p>
          <span>*, !, ^</span>: See "Remarks" column for details.
        </p>
      </div>
    </div>

    <script>
      const API_BASE_URL = "https://data.etabus.gov.hk/v1/transport/kmb";
      const STOP_CACHE_KEY = "kmb_stop_data_cache";
      const ROUTE_CACHE_KEY = "kmb_route_data_cache"; // Though not directly used for display
      const CACHE_EXPIRY_HOURS = 23; // Refresh slightly before 24h to be safe

      // Simplified override words for title casing
      const OVERRIDE_WORDS = new Set([
        "KMB", "LWB", "MTR", "BBI", "PTI", "McDonald's", "HSBC",
        "NT", "KLN", "HK", "Rd", "St", "Ave", "FEHD", "LCSD",
        "(N)", "(S)", "(E)", "(W)", "I", "II", "III", "IV", "V"
      ]);

      const stopNameInput = document.getElementById("stop-name-input");
      const routeFilterInput = document.getElementById("route-filter-input");
      const smartGroupingCheckbox = document.getElementById("smart-grouping-checkbox");
      const searchButton = document.getElementById("search-button");
      const statusMessagesDiv = document.getElementById("status-messages");
      const stopSelectionAreaDiv = document.getElementById("stop-selection-area");
      const etaResultsAreaDiv = document.getElementById("eta-results-area");

      // --- Caching Logic ---
      function saveToCache(key, data) {
        const cacheEntry = {
          timestamp: new Date().getTime(),
          data: data,
        };
        localStorage.setItem(key, JSON.stringify(cacheEntry));
      }

      function loadFromCache(key) {
        const item = localStorage.getItem(key);
        if (!item) return null;
        try {
          return JSON.parse(item);
        } catch (e) {
          localStorage.removeItem(key); // Remove corrupted cache
          return null;
        }
      }

      function isCacheValid(cacheEntry, expiryHours = CACHE_EXPIRY_HOURS) {
        if (!cacheEntry || !cacheEntry.timestamp) return false;
        const now = new Date().getTime();
        const cacheAgeHours = (now - cacheEntry.timestamp) / (1000 * 60 * 60);

        // KMB API updates around 05:00 HKT.
        // A more robust check would compare against 05:00 HKT of the current/previous day.
        // For simplicity, we use a fixed expiry.
        const cacheDate = new Date(cacheEntry.timestamp);
        const lastUpdateDate = new Date(cacheDate);
        lastUpdateDate.setHours(5, 0, 0, 0); // Set to 05:00 on cache date

        if (cacheDate.getHours() < 5) { // Cached before 5 AM
            lastUpdateDate.setDate(lastUpdateDate.getDate() -1); // Consider previous day's 5 AM
        }
        
        const nextUpdateTime = new Date(lastUpdateDate);
        nextUpdateTime.setDate(nextUpdateTime.getDate() + 1); // Next day 5 AM

        return now < nextUpdateTime.getTime();
      }

      // --- API Fetching ---
      async function fetchData(url) {
        try {
          const response = await fetch(url);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          return await response.json();
        } catch (error) {
          console.error("Fetch error:", error);
          throw error; // Re-throw to be caught by caller
        }
      }

      async function getStopList() {
        let cached = loadFromCache(STOP_CACHE_KEY);
        if (cached && isCacheValid(cached)) {
          console.log("Using cached stop list.");
          return cached.data.map(processStopRouteEntry);
        }
        console.log("Fetching fresh stop list.");
        setStatus("Loading stop list...", "loading");
        const data = await fetchData(`${API_BASE_URL}/stop`);
        const processedData = data.data.map(processStopRouteEntry);
        saveToCache(STOP_CACHE_KEY, processedData);
        clearStatus();
        return processedData;
      }
      
      async function getStopEta(stopId) {
        // No persistent caching for ETAs as they are real-time
        // In-memory caching could be added if needed for multiple calls to same stopId in one session
        setStatus(`Loading ETAs for stop ${stopId}...`, "loading");
        const data = await fetchData(`${API_BASE_URL}/stop-eta/${stopId}`);
        clearStatus();
        return data.data.map(processEtaEntry);
      }

      // --- Data Processing ---
      function customTitleCase(str) {
        if (!str) return "";
        return str.replace(/\w\S*/g, (txt) => {
            const upperTxt = txt.toUpperCase();
            if (OVERRIDE_WORDS.has(upperTxt)) return upperTxt;
            if (OVERRIDE_WORDS.has(txt)) return txt; // For mixed case like McDonald's
            return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
        });
      }

      function processName(name) {
        if (!name) return "";
        // Split "BBI-..." and "轉車站-..."
        name = name.replace(/(BBI)-/gi, "$1 - ");
        name = name.replace(/(轉車站)-/g, "$1 - ");
        return customTitleCase(name.trim());
      }
      
      function processStopRouteEntry(entry) {
        return {
          ...entry,
          name_en: processName(entry.name_en),
          name_tc: entry.name_tc, // Chinese names usually don't need title casing
          name_sc: entry.name_sc,
          // For routes:
          orig_en: entry.orig_en ? processName(entry.orig_en) : undefined,
          dest_en: entry.dest_en ? processName(entry.dest_en) : undefined,
        };
      }

      function processEtaEntry(entry) {
         return {
            ...entry,
            dest_en: processName(entry.dest_en)
         };
      }

      function parsePlatformFromStopName(stopNameEn) {
        if (!stopNameEn) return { baseName: stopNameEn, platform: null };
        
        // BBI Grouping: e.g., "Kwun Tong BBI - Millennium City (B10)"
        const bbiMatch = stopNameEn.match(/^(.*?\sBBI)\s*-\s*(.*)$/i);
        if (bbiMatch) {
            return { baseName: bbiMatch[1].trim(), platform: bbiMatch[2].trim() };
        }

        // Standard Platform: e.g., "Kwun Tong Swimming Pool (R1)" or "Bus Stop A"
        const platformMatch = stopNameEn.match(/^(.*?)\s*\(([A-Z0-9]+)\)$/i);
        if (platformMatch) {
            return { baseName: platformMatch[1].trim(), platform: platformMatch[2].trim() };
        }
        const trailingLetterMatch = stopNameEn.match(/^(.*?)\s+([A-Z])$/i);
         if (trailingLetterMatch && trailingLetterMatch[1].length > 3) { // Avoid matching single word + letter
            return { baseName: trailingLetterMatch[1].trim(), platform: trailingLetterMatch[2].trim() };
        }
        return { baseName: stopNameEn, platform: null };
      }


      // --- UI Rendering ---
      function setStatus(message, type = "info") { // types: info, loading, error
        statusMessagesDiv.textContent = message;
        statusMessagesDiv.className = `status-${type}`;
        statusMessagesDiv.style.display = "block";
      }
      function clearStatus() {
        statusMessagesDiv.textContent = "";
        statusMessagesDiv.style.display = "none";
      }

      function displayMatchingStops(stops, callbackOnSelect) {
        stopSelectionAreaDiv.innerHTML = ""; // Clear previous
        if (stops.length === 0) {
          setStatus("No stops found matching your query.", "info");
          return;
        }
        if (stops.length === 1) { // Auto-select if only one match
          callbackOnSelect([stops[0]]);
          return;
        }

        setStatus(`Multiple stops found (${stops.length}). Click to view ETAs or refine search.`, "info");
        const ul = document.createElement("ul");
        stops.forEach(stop => {
          const li = document.createElement("li");
          li.textContent = `${stop.name_en} / ${stop.name_tc} (ID: ${stop.stop})`;
          li.dataset.stopId = stop.stop;
          li.onclick = () => callbackOnSelect([stop]);
          ul.appendChild(li);
        });
        stopSelectionAreaDiv.appendChild(ul);
      }
      
      function getRouteColorClass(route) {
        if (!route) return 'route-default';
        const upperRoute = route.toUpperCase();
        if (upperRoute.startsWith('N')) return 'route-N';
        if (['A', 'E'].some(prefix => upperRoute.startsWith(prefix))) return 'route-A'; // Covers A and E
        if (upperRoute.startsWith('P')) return 'route-P';
        if (upperRoute.startsWith('R')) return 'route-R';
        if (upperRoute.startsWith('HK')) return 'route-HK'; // For HK Island routes if any by KMB
        if (/^[136]\d{0,2}[A-Z]?$/.test(upperRoute)) return 'route-1xx'; // 1, 1A, 101, 3xx, 6xx
        if (/^9\d{0,2}[A-Z]?$/.test(upperRoute)) return 'route-9xx'; // 9xx
        return 'route-default';
      }

      function formatEtaTime(isoTimestamp) {
        if (!isoTimestamp) return "-";
        try {
          const date = new Date(isoTimestamp);
          return date.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', hour12: false });
        } catch (e) {
          return "-";
        }
      }

      function renderEtaTable(stopIdentifier, etas, isGrouped = false, platformName = null) {
        const container = document.createElement("div");
        container.className = "eta-table-container";

        const title = document.createElement("h3");
        if (isGrouped) {
            title.textContent = `ETAs for ${stopIdentifier.groupName} ${platformName ? `- Platform: ${platformName}` : ''}`;
        } else {
            title.textContent = `ETAs for ${stopIdentifier.name_en} / ${stopIdentifier.name_tc}`;
        }
        container.appendChild(title);

        if (etas.length === 0) {
          const p = document.createElement("p");
          p.textContent = "No ETA data available for this stop/filter at the moment.";
          container.appendChild(p);
          etaResultsAreaDiv.appendChild(container);
          return;
        }

        const table = document.createElement("table");
        table.className = "eta-results";
        const thead = table.createTHead();
        const headerRow = thead.insertRow();
        const headers = ["Rt.", "Dest(EN)", "目的地", "ETA 1", "ETA 2", "ETA 3", "Remarks"];
        if (isGrouped && !platformName) headers.splice(1,0, "Plat."); // Add platform if grouped and not already part of title

        headers.forEach(text => {
          const th = document.createElement("th");
          th.textContent = text;
          headerRow.appendChild(th);
        });
        
        const tbody = table.createTBody();
        const remarkSymbols = ['*', '!', '^', '#', '$', '%']; // Extend if more needed
        let remarkSymbolIndex = 0;
        
        // Group ETAs by route, dir, service_type, dest_en, dest_tc to consolidate remarks
        const groupedEtas = {};
        etas.forEach(eta => {
            const key = `${eta.route}-${eta.dir}-${eta.service_type}-${eta.dest_en}-${eta.dest_tc}`;
            if (!groupedEtas[key]) {
                groupedEtas[key] = {
                    details: { ...eta }, // Take first one for route, dest etc.
                    timedEtas: [],
                    remarksOnly: [] // For remarks not tied to a specific ETA time
                };
            }
            if (eta.eta) { // Has a time
                groupedEtas[key].timedEtas.push(eta);
            } else if (eta.rmk_en || eta.rmk_tc || eta.rmk_sc) { // No time, but has a general remark
                groupedEtas[key].remarksOnly.push(eta);
            }
        });

        Object.values(groupedEtas).forEach(group => {
            const timedEtas = group.timedEtas.sort((a, b) => a.eta_seq - b.eta_seq).slice(0, 3);
            const allRemarksForDisplay = new Map(); // To collect unique remarks with symbols

            if (timedEtas.length > 0) {
                const row = tbody.insertRow();
                const firstEta = timedEtas[0]; // Use for common details

                let cellIndex = 0;
                row.insertCell(cellIndex++).innerHTML = `<span class="${getRouteColorClass(firstEta.route)}">${firstEta.route}</span>`;
                if (isGrouped && !platformName) { // If it's a general group table, show platform from ETA
                    const stopForPlatform = stopNameCache[firstEta.stop]; // Assuming stopNameCache is populated
                    row.insertCell(cellIndex++).textContent = stopForPlatform ? parsePlatformFromStopName(stopForPlatform.name_en).platform || '-' : '-';
                }
                row.insertCell(cellIndex++).textContent = firstEta.dest_en;
                row.insertCell(cellIndex++).textContent = firstEta.dest_tc;

                for (let i = 0; i < 3; i++) {
                    const td = row.insertCell(cellIndex++);
                    if (timedEtas[i]) {
                        let etaDisplay = formatEtaTime(timedEtas[i].eta);
                        let remarkText = timedEtas[i].rmk_en || timedEtas[i].rmk_tc || "";
                        if (timedEtas[i].rmk_en === "Scheduled Bus" || timedEtas[i].rmk_tc === "原定班次") {
                            td.classList.add("scheduled-eta");
                        } else if (remarkText) {
                            const symbol = remarkSymbols[remarkSymbolIndex % remarkSymbols.length];
                            etaDisplay += `<span class="remark-symbol">${symbol}</span>`;
                            if (!allRemarksForDisplay.has(remarkText)) {
                                allRemarksForDisplay.set(remarkText, symbol);
                                remarkSymbolIndex++;
                            }
                        }
                        td.innerHTML = etaDisplay;
                    } else {
                        td.textContent = "-";
                    }
                }
                // Remarks column
                const remarksCell = row.insertCell(cellIndex++);
                let remarksContent = "";
                allRemarksForDisplay.forEach((symbol, text) => {
                    remarksContent += `<p>${symbol} ${text}</p>`;
                });
                remarksCell.innerHTML = remarksContent || "-";
            }

            // Handle remarks that are not tied to a specific ETA time (e.g., "Service suspended")
            if (group.remarksOnly.length > 0) {
                if (timedEtas.length > 0) { // Add separator if there were timed ETAs
                    const sepRow = tbody.insertRow();
                    const sepCell = sepRow.insertCell();
                    sepCell.colSpan = headers.length;
                    sepCell.classList.add("eta-separator");
                }
                group.remarksOnly.forEach(remarkEta => {
                    const row = tbody.insertRow();
                    row.classList.add("remark-only-row");
                    
                    let cellIndex = 0;
                    row.insertCell(cellIndex++).innerHTML = `<span class="${getRouteColorClass(remarkEta.route)}">${remarkEta.route}</span>`;
                     if (isGrouped && !platformName) {
                        const stopForPlatform = stopNameCache[remarkEta.stop];
                        row.insertCell(cellIndex++).textContent = stopForPlatform ? parsePlatformFromStopName(stopForPlatform.name_en).platform || '-' : '-';
                    }
                    row.insertCell(cellIndex++).textContent = remarkEta.dest_en;
                    row.insertCell(cellIndex++).textContent = remarkEta.dest_tc;
                    
                    const remarkCell = row.insertCell(cellIndex++);
                    remarkCell.colSpan = headers.length - cellIndex +1; // Span remaining ETA and Remarks columns
                    remarkCell.textContent = remarkEta.rmk_en || remarkEta.rmk_tc || remarkEta.rmk_sc;
                });
            }
        });

        container.appendChild(table);
        etaResultsAreaDiv.appendChild(container);
      }
      
      let stopNameCache = {}; // To resolve stop names for platform display in grouped ETAs

      // --- Main Search Logic ---
      async function handleSearch() {
        const stopQuery = stopNameInput.value.trim();
        const routeFilters = routeFilterInput.value.trim().toUpperCase().split(',').filter(r => r);
        const useSmartGrouping = smartGroupingCheckbox.checked;

        if (!stopQuery) {
          setStatus("Please enter a bus stop name.", "error");
          return;
        }

        etaResultsAreaDiv.innerHTML = ""; // Clear previous results
        stopSelectionAreaDiv.innerHTML = ""; // Clear stop selection
        setStatus("Searching...", "loading");

        try {
          const allStops = await getStopList();
          stopNameCache = {}; // Reset and populate for current search
          allStops.forEach(s => stopNameCache[s.stop] = {name_en: s.name_en, name_tc: s.name_tc});


          const lowerStopQuery = stopQuery.toLowerCase();
          let matchedStops = allStops.filter(stop => 
            (stop.name_en && stop.name_en.toLowerCase().includes(lowerStopQuery)) ||
            (stop.name_tc && stop.name_tc.includes(stopQuery)) || // Chinese exact match for simplicity
            (stop.name_sc && stop.name_sc.includes(stopQuery))
          );

          // Sort matched stops alphabetically by processed English name
          matchedStops.sort((a,b) => (a.name_en || "").localeCompare(b.name_en || ""));


          if (matchedStops.length === 0) {
            setStatus("No stops found matching your query.", "info");
            return;
          }
          
          clearStatus(); // Clear "Searching..."

          if (useSmartGrouping) {
            const grouped = {};
            matchedStops.forEach(stop => {
                const { baseName, platform } = parsePlatformFromStopName(stop.name_en);
                if (!grouped[baseName]) {
                    grouped[baseName] = {
                        groupName: baseName,
                        stops: [],
                        platforms: new Set() // To avoid duplicate platform entries if baseName itself is a stop
                    };
                }
                grouped[baseName].stops.push(stop);
                if (platform) grouped[baseName].platforms.add(platform);
            });

            for (const groupKey in grouped) {
                const group = grouped[groupKey];
                let allEtasForGroup = [];
                for (const stop of group.stops) {
                    let etas = await getStopEta(stop.stop);
                    if (routeFilters.length > 0) {
                        etas = etas.filter(eta => routeFilters.includes(eta.route.toUpperCase()));
                    }
                    // Add stop_id to each eta for platform resolution if needed later
                    etas.forEach(e => e.original_stop_id = stop.stop); 
                    allEtasForGroup.push(...etas);
                }
                if (allEtasForGroup.length > 0) {
                    // If only one platform or no distinct platforms, render as one table
                    // Otherwise, could consider sub-tables per platform or one large table with platform column
                    renderEtaTable({ groupName: group.groupName }, allEtasForGroup, true, null);
                } else if (group.stops.length > 0) {
                     renderEtaTable({ groupName: group.groupName }, [], true, null); // Show empty table
                }
            }

          } else { // No smart grouping
            // If more than a few stops, might want to use displayMatchingStops
            // For now, fetch for all matched directly
            if (matchedStops.length > 5 && stopSelectionAreaDiv.innerHTML === "") { // Avoid re-prompting if already selected
                 displayMatchingStops(matchedStops, async (selectedStops) => {
                    stopSelectionAreaDiv.innerHTML = ""; // Clear selection list
                    for (const stop of selectedStops) {
                        let etas = await getStopEta(stop.stop);
                        if (routeFilters.length > 0) {
                            etas = etas.filter(eta => routeFilters.includes(eta.route.toUpperCase()));
                        }
                        renderEtaTable(stop, etas);
                    }
                 });
            } else {
                for (const stop of matchedStops) {
                    let etas = await getStopEta(stop.stop);
                    if (routeFilters.length > 0) {
                        etas = etas.filter(eta => routeFilters.includes(eta.route.toUpperCase()));
                    }
                    renderEtaTable(stop, etas);
                }
            }
          }

        } catch (error) {
          console.error("Search failed:", error);
          setStatus(`Error: ${error.message}. Could not fetch data.`, "error");
        }
      }

      searchButton.addEventListener("click", handleSearch);
      stopNameInput.addEventListener("keypress", (event) => {
        if (event.key === "Enter") {
          handleSearch();
        }
      });
      routeFilterInput.addEventListener("keypress", (event) => {
        if (event.key === "Enter") {
          handleSearch();
        }
      });

      // Initial status
      setStatus("Enter a stop name to begin.", "info");
    </script>
  </body>
</html>
