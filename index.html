<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>KMB Real-Time ETA</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f4f4f4;
        color: #333;
      }
      .container {
        max-width: 1000px;
        margin: auto;
        background-color: #fff;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      }
      h1 {
        text-align: center;
        color: #d71920; /* KMB Red */
      }
      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        margin-bottom: 20px;
        align-items: flex-end;
      }
      .controls label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
      }
      .controls input[type="text"],
      .controls input[type="checkbox"] {
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
      }
      .controls input[type="text"] {
        flex-grow: 1;
        min-width: 200px;
      }
      .controls button {
        padding: 10px 15px;
        background-color: #d71920;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 1em;
      }
      .controls button:hover {
        background-color: #b8141a;
      }
      .grouping-control {
        display: flex;
        align-items: center;
        gap: 5px;
      }

      #status-messages {
        margin-bottom: 15px;
        padding: 10px;
        border-radius: 4px;
      }
      .status-loading {
        background-color: #eef;
        border: 1px solid #ccf;
      }
      .status-error {
        background-color: #fee;
        border: 1px solid #fcc;
        color: red;
      }
      .status-info {
        background-color: #eff;
        border: 1px solid #cff;
      }

      #stop-selection-area ul {
        list-style-type: none;
        padding: 0;
      }
      #stop-selection-area li {
        padding: 8px;
        border-bottom: 1px solid #eee;
        cursor: pointer;
      }
      #stop-selection-area li:hover {
        background-color: #f0f0f0;
      }
      #stop-selection-area li:last-child {
        border-bottom: none;
      }

      .eta-table-container {
        margin-bottom: 25px;
        overflow-x: auto;
      }
      .eta-table-container h3 {
        margin-top: 0;
        color: #555;
      }
      table.eta-results {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9em;
        margin-bottom: 10px;
      }
      table.eta-results th,
      table.eta-results td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
        white-space: nowrap;
      }
      table.eta-results th {
        background-color: #f0f0f0;
      }
      .scheduled-eta {
        color: grey;
      }
      .remark-symbol {
        font-weight: bold;
        margin-left: 2px;
      }
      .remark-only-row td {
        text-align: center !important;
        font-style: italic;
        color: #555;
      }
      .eta-separator td {
        border-top: 2px dotted #ccc !important;
        height: 0;
        padding: 0 !important;
        line-height: 0;
      }

      /* Route Colors - Add more as needed */
      .route-N { color: #000080; font-weight: bold; } /* Navy for N-routes */
      .route-1xx, .route-3xx, .route-6xx { color: #800000; } /* Maroon for 1/3/6xx */
      .route-9xx { color: #006400; } /* DarkGreen for 9xx */
      .route-P { color: #800080; } /* Purple for P-routes */
      .route-R { color: #ff8c00; } /* DarkOrange for R-routes */
      .route-HK { color: #228B22; } /* ForestGreen for HK-routes */
      .route-A, .route-E { color: #4682B4; } /* SteelBlue for Airport routes */
      .route-default { color: #333; }

      #legend {
        margin-top: 20px;
        padding: 10px;
        background-color: #f9f9f9;
        border: 1px solid #eee;
        border-radius: 4px;
        font-size: 0.9em;
      }
      #legend p { margin: 5px 0; }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>KMB Real-Time Bus ETA</h1>

      <div class="controls">
        <div>
          <label for="stop-name-input">Bus Stop Name (EN/CN):</label>
          <input
            type="text"
            id="stop-name-input"
            placeholder="e.g., Tsim Sha Tsui or 尖沙咀"
          />
        </div>
        <div>
          <label for="route-filter-input">Filter Routes (optional):</label>
          <input
            type="text"
            id="route-filter-input"
            placeholder="e.g., 1A,271"
          />
        </div>
        <div class="grouping-control">
          <input type="checkbox" id="smart-grouping-checkbox" />
          <label for="smart-grouping-checkbox">Smart Grouping</label>
        </div>
        <button id="search-button">Search ETAs</button>
      </div>

      <div id="status-messages"></div>
      <div id="stop-selection-area">
        <!-- Matching stops will be listed here if multiple -->
      </div>
      <div id="eta-results-area">
        <!-- ETA tables will be rendered here -->
      </div>
      <div id="legend">
        <p><strong>Legend:</strong></p>
        <p><span class="scheduled-eta">Grey Text</span>: Scheduled Bus</p>
        <p>
          <span>*, !, ^</span>: See "Remarks" column for details.
        </p>
      </div>
    </div>

    <script>
      const API_BASE_URL = "https://data.etabus.gov.hk/v1/transport/kmb";
      const STOP_CACHE_KEY = "kmb_stop_data_cache";
      const ROUTE_CACHE_KEY = "kmb_route_data_cache"; // Though not directly used for display
      const CACHE_EXPIRY_HOURS = 23; // Refresh slightly before 24h to be safe

      const OVERRIDE_WORDS = new Set([
        "KMB", "LWB", "MTR", "BBI", "PTI", "McDonald's", "HSBC",
        "NT", "KLN", "HK", "Rd", "St", "Ave", "FEHD", "LCSD",
        "(N)", "(S)", "(E)", "(W)", "I", "II", "III", "IV", "V"
      ]);

      const stopNameInput = document.getElementById("stop-name-input");
      const routeFilterInput = document.getElementById("route-filter-input");
      const smartGroupingCheckbox = document.getElementById("smart-grouping-checkbox");
      const searchButton = document.getElementById("search-button");
      const statusMessagesDiv = document.getElementById("status-messages");
      const stopSelectionAreaDiv = document.getElementById("stop-selection-area"); // Kept for potential future use or different scenarios
      const etaResultsAreaDiv = document.getElementById("eta-results-area");
      
      let stopNameCache = {}; // To resolve stop names for platform display in grouped ETAs


      // --- Caching Logic ---
      function saveToCache(key, data) {
        const cacheEntry = {
          timestamp: new Date().getTime(),
          data: data,
        };
        localStorage.setItem(key, JSON.stringify(cacheEntry));
      }

      function loadFromCache(key) {
        const item = localStorage.getItem(key);
        if (!item) return null;
        try {
          return JSON.parse(item);
        } catch (e) {
          localStorage.removeItem(key);
          return null;
        }
      }

      function isCacheValid(cacheEntry, expiryHours = CACHE_EXPIRY_HOURS) {
        if (!cacheEntry || !cacheEntry.timestamp) return false;
        const now = new Date().getTime();
        const cacheDate = new Date(cacheEntry.timestamp);
        const lastUpdateDate = new Date(cacheDate);
        lastUpdateDate.setHours(5, 0, 0, 0); 

        if (cacheDate.getHours() < 5) {
            lastUpdateDate.setDate(lastUpdateDate.getDate() -1);
        }
        
        const nextUpdateTime = new Date(lastUpdateDate);
        nextUpdateTime.setDate(nextUpdateTime.getDate() + 1);

        return now < nextUpdateTime.getTime();
      }

      // --- API Fetching ---
      async function fetchData(url) {
        try {
          const response = await fetch(url);
          if (!response.ok) {
            const errorBody = await response.text();
            console.error(`HTTP error! status: ${response.status}, body: ${errorBody}`);
            throw new Error(`HTTP error ${response.status}. See console for details.`);
          }
          return await response.json();
        } catch (error) {
          console.error("Fetch error:", error);
          throw error;
        }
      }

      async function getStopList() {
        let cached = loadFromCache(STOP_CACHE_KEY);
        if (cached && isCacheValid(cached)) {
          console.log("Using cached stop list.");
          // Ensure cache is processed if it wasn't already
          return Array.isArray(cached.data) ? cached.data.map(entry => entry.name_en ? entry : processStopRouteEntry(entry)) : [];
        }
        console.log("Fetching fresh stop list.");
        setStatus("Loading stop list...", "loading");
        const data = await fetchData(`${API_BASE_URL}/stop`);
        const processedData = data.data.map(processStopRouteEntry);
        saveToCache(STOP_CACHE_KEY, processedData);
        clearStatus();
        return processedData;
      }
      
      async function getStopEta(stopId) {
        setStatus(`Loading ETAs for stop ${stopId}...`, "loading");
        const data = await fetchData(`${API_BASE_URL}/stop-eta/${stopId}`);
        clearStatus();
        return data.data.map(processEtaEntry);
      }

      // --- Data Processing ---
      function customTitleCase(str) {
        if (!str) return "";
        return str.replace(/\w\S*/g, (txt) => {
            const upperTxt = txt.toUpperCase();
            if (OVERRIDE_WORDS.has(upperTxt)) return upperTxt;
            if (OVERRIDE_WORDS.has(txt)) return txt;
            return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
        });
      }

      function processName(name) {
        if (!name) return "";
        name = name.replace(/(BBI)-/gi, "$1 - ");
        name = name.replace(/(轉車站)-/g, "$1 - ");
        return customTitleCase(name.trim());
      }
      
      function processStopRouteEntry(entry) {
        return {
          ...entry,
          name_en: processName(entry.name_en),
          name_tc: entry.name_tc,
          name_sc: entry.name_sc,
          orig_en: entry.orig_en ? processName(entry.orig_en) : undefined,
          dest_en: entry.dest_en ? processName(entry.dest_en) : undefined,
        };
      }

      function processEtaEntry(entry) {
         return {
            ...entry,
            dest_en: processName(entry.dest_en)
         };
      }

      function parsePlatformFromStopName(stopNameEn) {
        if (!stopNameEn) return { baseName: stopNameEn, platform: null };
        
        const bbiMatch = stopNameEn.match(/^(.*?\sBBI)\s*-\s*(.*)$/i);
        if (bbiMatch) {
            return { baseName: bbiMatch[1].trim(), platform: bbiMatch[2].trim() };
        }

        const platformMatch = stopNameEn.match(/^(.*?)\s*\(([A-Z0-9]+)\)$/i);
        if (platformMatch) {
            return { baseName: platformMatch[1].trim(), platform: platformMatch[2].trim() };
        }
        const trailingLetterMatch = stopNameEn.match(/^(.*?)\s+([A-Z])$/i);
         if (trailingLetterMatch && trailingLetterMatch[1].length > 3) { 
            return { baseName: trailingLetterMatch[1].trim(), platform: trailingLetterMatch[2].trim() };
        }
        return { baseName: stopNameEn, platform: null };
      }


      // --- UI Rendering ---
      function setStatus(message, type = "info") {
        statusMessagesDiv.textContent = message;
        statusMessagesDiv.className = `status-${type}`;
        statusMessagesDiv.style.display = "block";
      }
      function clearStatus() {
        statusMessagesDiv.textContent = "";
        statusMessagesDiv.style.display = "none";
      }
      
      function getRouteColorClass(route) {
        if (!route) return 'route-default';
        const upperRoute = route.toUpperCase();
        if (upperRoute.startsWith('N')) return 'route-N';
        if (['A', 'E'].some(prefix => upperRoute.startsWith(prefix))) return 'route-A';
        if (upperRoute.startsWith('P')) return 'route-P';
        if (upperRoute.startsWith('R')) return 'route-R';
        if (upperRoute.startsWith('HK')) return 'route-HK';
        if (/^[136]\d{0,2}[A-Z]?$/.test(upperRoute)) return 'route-1xx';
        if (/^9\d{0,2}[A-Z]?$/.test(upperRoute)) return 'route-9xx';
        return 'route-default';
      }

      function formatEtaTime(isoTimestamp) {
        if (!isoTimestamp) return "-";
        try {
          const date = new Date(isoTimestamp);
          return date.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', hour12: false });
        } catch (e) {
          return "-";
        }
      }

      function renderEtaTable(stopIdentifier, etasFromApi, isGrouped = false, platformForTitle = null) {
        const container = document.createElement("div");
        container.className = "eta-table-container";

        const title = document.createElement("h3");
        if (isGrouped) {
            title.textContent = `ETAs for ${stopIdentifier.groupName} ${platformForTitle ? `- Platform: ${platformForTitle}` : ''}`;
        } else {
            title.textContent = `ETAs for ${stopIdentifier.name_en} / ${stopIdentifier.name_tc}`;
        }
        container.appendChild(title);

        if (!etasFromApi || etasFromApi.length === 0) {
          const p = document.createElement("p");
          p.textContent = "No ETA data available for this stop/filter at the moment.";
          container.appendChild(p);
          etaResultsAreaDiv.appendChild(container);
          return;
        }

        const table = document.createElement("table");
        table.className = "eta-results";
        const thead = table.createTHead();
        const headerRow = thead.insertRow();
        const headersBase = ["Rt.", "Dest(EN)", "目的地", "ETA 1", "ETA 2", "ETA 3", "Remarks"];
        let headers = [...headersBase]; // Make a copy
        
        // Add "Plat." column if it's a grouped view and we are not showing a specific platform in the title
        const showPlatformColumn = isGrouped && !platformForTitle;
        if (showPlatformColumn) {
            headers.splice(1, 0, "Plat.");
        }

        headers.forEach(text => {
          const th = document.createElement("th");
          th.textContent = text;
          headerRow.appendChild(th);
        });
        
        const tbody = table.createTBody();
        const remarkSymbols = ['*', '!', '^', '#', '$', '%'];
        let remarkSymbolIndex = 0;
        
        const processedGroupedEtas = {};
        const committedServiceTypes = {};

        etasFromApi.forEach(eta => {
            const primaryKey = `${eta.route}-${eta.dir}-${eta.dest_en}-${eta.dest_tc}`;

            if (!committedServiceTypes[primaryKey]) {
                committedServiceTypes[primaryKey] = eta.service_type;
            }

            if (eta.service_type === committedServiceTypes[primaryKey]) {
                if (!processedGroupedEtas[primaryKey]) {
                    processedGroupedEtas[primaryKey] = {
                        details: { ...eta },
                        timedEtas: [],
                        remarksOnly: []
                    };
                }
                if (eta.eta) {
                    processedGroupedEtas[primaryKey].timedEtas.push(eta);
                } else if (eta.rmk_en || eta.rmk_tc || eta.rmk_sc) {
                    processedGroupedEtas[primaryKey].remarksOnly.push(eta);
                }
            }
        });

        Object.values(processedGroupedEtas).forEach(group => {
            const timedEtas = group.timedEtas.sort((a, b) => a.eta_seq - b.eta_seq).slice(0, 3);
            const allRemarksForDisplay = new Map();

            if (timedEtas.length > 0) {
                const row = tbody.insertRow();
                const firstEta = timedEtas[0]; 

                let cellIndex = 0;
                row.insertCell(cellIndex++).innerHTML = `<span class="${getRouteColorClass(firstEta.route)}">${firstEta.route}</span>`;
                
                if (showPlatformColumn) {
                    const originalStopDetails = stopNameCache[firstEta.stop]; // 'stop' here is the stop_id from ETA
                    row.insertCell(cellIndex++).textContent = originalStopDetails ? parsePlatformFromStopName(originalStopDetails.name_en).platform || '-' : '-';
                }

                row.insertCell(cellIndex++).textContent = firstEta.dest_en;
                row.insertCell(cellIndex++).textContent = firstEta.dest_tc;

                for (let i = 0; i < 3; i++) {
                    const td = row.insertCell(cellIndex++);
                    if (timedEtas[i]) {
                        let etaDisplay = formatEtaTime(timedEtas[i].eta);
                        let remarkText = timedEtas[i].rmk_en || timedEtas[i].rmk_tc || "";
                        if (timedEtas[i].rmk_en === "Scheduled Bus" || timedEtas[i].rmk_tc === "原定班次") {
                            td.classList.add("scheduled-eta");
                        } else if (remarkText) {
                            const symbol = remarkSymbols[remarkSymbolIndex % remarkSymbols.length];
                            etaDisplay += `<span class="remark-symbol">${symbol}</span>`;
                            if (!allRemarksForDisplay.has(remarkText)) {
                                allRemarksForDisplay.set(remarkText, symbol);
                                remarkSymbolIndex++;
                            }
                        }
                        td.innerHTML = etaDisplay;
                    } else {
                        td.textContent = "-";
                    }
                }
                const remarksCell = row.insertCell(cellIndex++);
                let remarksContent = "";
                allRemarksForDisplay.forEach((symbol, text) => {
                    remarksContent += `<p style="margin:0; padding:0;">${symbol} ${text}</p>`;
                });
                remarksCell.innerHTML = remarksContent || "-";
            }

            if (group.remarksOnly.length > 0) {
                if (timedEtas.length > 0) {
                    const sepRow = tbody.insertRow();
                    const sepCell = sepRow.insertCell();
                    sepCell.colSpan = headers.length;
                    sepCell.classList.add("eta-separator");
                }
                group.remarksOnly.forEach(remarkEta => {
                    const row = tbody.insertRow();
                    row.classList.add("remark-only-row");
                    
                    let cellIndex = 0;
                    row.insertCell(cellIndex++).innerHTML = `<span class="${getRouteColorClass(remarkEta.route)}">${remarkEta.route}</span>`;
                    
                    if (showPlatformColumn) {
                        const originalStopDetails = stopNameCache[remarkEta.stop];
                        row.insertCell(cellIndex++).textContent = originalStopDetails ? parsePlatformFromStopName(originalStopDetails.name_en).platform || '-' : '-';
                    }

                    row.insertCell(cellIndex++).textContent = remarkEta.dest_en;
                    row.insertCell(cellIndex++).textContent = remarkEta.dest_tc;
                    
                    const remarkCell = row.insertCell(cellIndex++);
                    // Calculate colspan correctly based on whether platform column is shown
                    remarkCell.colSpan = headersBase.length - 3; // 3 fixed columns before ETAs (Rt, DestEN, DestTC)
                    remarkCell.textContent = remarkEta.rmk_en || remarkEta.rmk_tc || remarkEta.rmk_sc;
                });
            }
        });

        container.appendChild(table);
        etaResultsAreaDiv.appendChild(container);
      }
      
      // --- Main Search Logic ---
      async function handleSearch() {
        const stopQuery = stopNameInput.value.trim();
        const routeFilters = routeFilterInput.value.trim().toUpperCase().split(',').filter(r => r);
        const useSmartGrouping = smartGroupingCheckbox.checked;

        if (!stopQuery) {
          setStatus("Please enter a bus stop name.", "error");
          return;
        }

        etaResultsAreaDiv.innerHTML = ""; 
        stopSelectionAreaDiv.innerHTML = ""; 
        setStatus("Searching...", "loading");

        try {
          const allStops = await getStopList();
          stopNameCache = {}; 
          allStops.forEach(s => stopNameCache[s.stop] = {name_en: s.name_en, name_tc: s.name_tc});

          const lowerStopQuery = stopQuery.toLowerCase();
          let matchedStops = allStops.filter(stop => 
            (stop.name_en && stop.name_en.toLowerCase().includes(lowerStopQuery)) ||
            (stop.name_tc && stop.name_tc.includes(stopQuery)) || 
            (stop.name_sc && stop.name_sc.includes(stopQuery))
          );

          matchedStops.sort((a,b) => (a.name_en || "").localeCompare(b.name_en || ""));

          if (matchedStops.length === 0) {
            setStatus("No stops found matching your query.", "info");
            return;
          }
          
          clearStatus(); 

          if (useSmartGrouping) {
            const groupedByBaseName = {};
            matchedStops.forEach(stop => {
                const { baseName } = parsePlatformFromStopName(stop.name_en);
                if (!groupedByBaseName[baseName]) {
                    groupedByBaseName[baseName] = {
                        groupName: baseName,
                        stops: []
                    };
                }
                groupedByBaseName[baseName].stops.push(stop);
            });

            for (const groupKey in groupedByBaseName) {
                const group = groupedByBaseName[groupKey];
                let allEtasForGroup = [];
                for (const stop of group.stops) {
                    let etas = await getStopEta(stop.stop);
                    if (routeFilters.length > 0) {
                        etas = etas.filter(eta => routeFilters.includes(eta.route.toUpperCase()));
                    }
                    etas.forEach(e => e.original_stop_id = stop.stop); 
                    allEtasForGroup.push(...etas);
                }
                if (allEtasForGroup.length > 0) {
                    renderEtaTable({ groupName: group.groupName }, allEtasForGroup, true, null);
                } else if (group.stops.length > 0) {
                     renderEtaTable({ groupName: group.groupName }, [], true, null);
                }
            }
          } else { // No smart grouping - display all matched stops directly
            for (const stop of matchedStops) {
                let etasFromApi = await getStopEta(stop.stop);
                if (routeFilters.length > 0) {
                    etasFromApi = etasFromApi.filter(eta => routeFilters.includes(eta.route.toUpperCase()));
                }
                renderEtaTable(stop, etasFromApi, false);
            }
          }

        } catch (error) {
          console.error("Search failed:", error);
          setStatus(`Error: ${error.message}. Could not fetch data. Check console.`, "error");
        }
      }

      searchButton.addEventListener("click", handleSearch);
      stopNameInput.addEventListener("keypress", (event) => {
        if (event.key === "Enter") {
          handleSearch();
        }
      });
      routeFilterInput.addEventListener("keypress", (event) => {
        if (event.key === "Enter") {
          handleSearch();
        }
      });

      setStatus("Enter a stop name to begin.", "info");
    </script>

  </body>
</html>
