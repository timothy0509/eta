<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pak Hung House - KMB ETA</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body class="dark-mode">
    <div class="container">
      <div class="header-controls">
        <h1>Pak Hung House - Bus ETA</h1>
      </div>

      <div id="status-messages"></div>
      <div id="eta-results-area"></div>
      <div id="legend">
        <p><strong>Legend:</strong></p>
        <p><span class="scheduled-eta">Grey Text / Italic</span>: Scheduled Bus</p>
        <p>
          <span>*, !, ^</span>: See "Remarks" column for details.
        </p>
        <p>Route colors indicate service type (e.g., Overnight, Airport).</p>
      </div>
    </div>

    <script>
      // --- START OF SCRIPT (All previous constants and helper functions for singyin.html) ---
      const API_BASE_URL = "https://data.etabus.gov.hk/v1/transport/kmb";
      const ETA_REFRESH_INTERVAL = 60000; // 1 minute for data refresh
      const COUNTDOWN_UPDATE_INTERVAL = 1000; // 1 second for countdown UI update

      const statusMessagesDiv = document.getElementById("status-messages");
      const etaResultsAreaDiv = document.getElementById("eta-results-area");
      
      let dataRefreshTimer = null; 
      let activeCountdownIntervals = []; // Store countdown interval IDs

      const predefinedStopGroups = [ /* ... same ... */ ];

      // Utility functions (saveToCache, loadFromCache, isCacheValid, fetchData, getStopEta, 
      // processName, setStatus, clearStatus, getRouteColorClass, formatRouteNumberForDisplay, 
      // parseRouteForSorting) are assumed to be here and are the same as in index.html.
      // For brevity, I'll skip pasting them again.
      // formatEtaTime will be for the original scheduled time, not countdown
      function formatScheduledEtaTime(isoTimestamp) { 
        if (!isoTimestamp) return "";
        try { 
            return new Date(isoTimestamp).toLocaleTimeString('en-GB', { 
                hour: '2-digit', 
                minute: '2-digit',
                hour12: false 
            }); 
        }
        catch (e) { return ""; }
      }
      // --- END OF PREVIOUSLY EXISTING HELPER FUNCTIONS ---

      function clearAllCountdowns_singyin() {
        activeCountdownIntervals.forEach(intervalId => clearInterval(intervalId));
        activeCountdownIntervals = [];
      }

      function updateCountdown_singyin(etaCell, etaTimestamp) {
        const now = new Date().getTime();
        const etaTime = new Date(etaTimestamp).getTime();
        const diff = etaTime - now;

        if (diff <= 0) {
          etaCell.textContent = "Due";
          etaCell.classList.add("eta-due");
          return false; 
        }
        const minutes = Math.floor(diff / (1000 * 60));
        const seconds = Math.floor((diff % (1000 * 60)) / 1000);
        etaCell.textContent = `${minutes} min ${seconds < 10 ? '0' : ''}${seconds} sec`;
        return true;
      }

      function renderEtaTable(groupDisplayName, etasFromApi, stopPlatformMap) { // stopPlatformMap is used here
        console.log(`Rendering ETA table for (singyin): ${groupDisplayName}`);
        let groupContainer = document.getElementById(`group-container-${groupDisplayName.replace(/\s+/g, '-')}`);
        if (!groupContainer) { /* ... create groupContainer ... */ }
        groupContainer.innerHTML = '';
        const tableContainer = document.createElement("div"); /* ... create tableContainer ... */
        const title = document.createElement("h3"); /* ... set title ... */
        tableContainer.appendChild(title);

        if (!etasFromApi || etasFromApi.length === 0) { /* ... empty state ... */ return; }

        const table = document.createElement("table"); /* ... create table ... */
        const thead = table.createTHead(); /* ... create thead ... */
        const headerRow = thead.insertRow();
        const headersBase = ["Rt.", "Plat.", "Dest(EN)", "目的地", "ETA 1", "ETA 2", "ETA 3", "Remarks"]; // Platform column is present
        headersBase.forEach(text => { /* ... add headers ... */ });
        
        const tbody = table.createTBody();
        const fragment = document.createDocumentFragment();
        const remarkSymbols = ['*', '!', '^', '#', '$', '%'];
        let remarkSymbolIndex = 0;
        const processedGroupedEtas = {}; /* ... same processing ... */
        const committedServiceTypes = {}; /* ... same processing ... */
        etasFromApi.forEach(eta => { /* ... same processing ... */ });
        const sortedEtaGroups = Object.values(processedGroupedEtas).sort((groupA, groupB) => { /* ... same sorting ... */ });

        sortedEtaGroups.forEach(group => {
            const timedEtas = group.timedEtas.sort((a, b) => a.eta_seq - b.eta_seq).slice(0, 3);
            const allRemarksForDisplay = new Map();
            const platformCode = stopPlatformMap[group.details.stop] || '-';

            if (timedEtas.length > 0) {
                const row = document.createElement("tr");
                const firstEta = timedEtas[0]; 
                
                const routeCell = document.createElement("td"); /* ... route cell ... */ row.appendChild(routeCell);
                const platCell = document.createElement("td"); platCell.textContent = platformCode; row.appendChild(platCell);
                const destEnCell = document.createElement("td"); /* ... dest EN ... */ row.appendChild(destEnCell);
                const destTcCell = document.createElement("td"); /* ... dest TC ... */ row.appendChild(destTcCell);

                for (let i = 0; i < 3; i++) {
                    const td = document.createElement("td");
                    if (timedEtas[i] && timedEtas[i].eta) {
                        const etaTimestamp = timedEtas[i].eta;
                        td.dataset.etaTimestamp = etaTimestamp;
                        updateCountdown_singyin(td, etaTimestamp);

                        if (new Date(etaTimestamp).getTime() > new Date().getTime()) {
                            const intervalId = setInterval(() => {
                                if (!updateCountdown_singyin(td, etaTimestamp)) {
                                    clearInterval(intervalId);
                                }
                            }, COUNTDOWN_UPDATE_INTERVAL);
                            activeCountdownIntervals.push(intervalId);
                        }
                        const scheduledTimeSpan = document.createElement("span"); /* ... scheduled time span ... */ td.appendChild(scheduledTimeSpan);
                        let remarkText = timedEtas[i].rmk_en || timedEtas[i].rmk_tc || "";
                        if (timedEtas[i].rmk_en === "Scheduled Bus" || timedEtas[i].rmk_tc === "原定班次") {
                            td.classList.add("scheduled-eta-countdown");
                        } else if (remarkText) { /* ... remark symbol ... */ }
                    } else { td.textContent = "-"; }
                    row.appendChild(td);
                }
                const remarksCell = document.createElement("td"); /* ... remarks cell ... */ row.appendChild(remarksCell);
                fragment.appendChild(row);
            }
            // ... (handle remarksOnly rows, including platform cell) ...
        });
        tbody.appendChild(fragment);
        tableContainer.appendChild(table);
        groupContainer.appendChild(tableContainer);
      }
      
      async function loadSingYinEtas(isUpdate = false) {
        console.log(isUpdate ? "Auto-refreshing ETAs..." : "Initial loadSingYinEtas triggered.");
        if (!isUpdate) {
            etaResultsAreaDiv.innerHTML = ""; 
            setStatus("Loading Pak Hung House ETAs...", "loading");
        } else {
            console.log("Background update in progress...");
        }
        clearAllCountdowns_singyin(); // Clear old countdowns before fetching new data

        try {
            for (const group of predefinedStopGroups) {
                let allEtasForGroup = [];
                const stopPlatformMap = {}; 
                if (!isUpdate) { /* ... setStatus ... */ }

                const etaPromises = group.stops.map(stop => { /* ... same Promise.all logic ... */ });
                const etaResultsArray = await Promise.all(etaPromises);
                etaResultsArray.forEach(etas => { allEtasForGroup.push(...etas); });
                
                if (allEtasForGroup.length > 0 || group.stops.length > 0) {
                    renderEtaTable(group.groupName, allEtasForGroup, stopPlatformMap); // Pass stopPlatformMap
                }
            }
            if (etaResultsAreaDiv.innerHTML === "" && !isUpdate) { /* ... setStatus ... */ }
            else if (!isUpdate) { clearStatus(); }
            else { console.log("Silent update complete."); }
        } catch (error) { /* ... error handling ... */ }
      }

      document.addEventListener('DOMContentLoaded', () => {
        loadSingYinEtas();
        if (dataRefreshTimer) clearInterval(dataRefreshTimer);
        dataRefreshTimer = setInterval(() => loadSingYinEtas(true), ETA_REFRESH_INTERVAL);
      });
    </script>

    <footer>
      <p>Made by Timothy</p>
    </footer>
  </body>
</html>
